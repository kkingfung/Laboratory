using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

namespace Laboratory.Models.Input
{
    /// <summary>
    /// Generated Input Actions class for PlayerControls
    /// This is a temporary placeholder - ideally this would be auto-generated by Unity
    /// </summary>
    public class PlayerControls : IInputActionCollection, IDisposable
    {
        private readonly InputActionAsset m_Asset;
        private readonly InputActionMap m_Player;
        private readonly InputAction m_Player_Move;
        private readonly InputAction m_Player_Look;
        private readonly InputAction m_Player_Attack;
        private readonly InputAction m_Player_Jump;
        private readonly InputAction m_Player_Pause;
        private readonly InputAction m_Player_Roll;
        private readonly InputAction m_Player_CharSkill;
        private readonly InputAction m_Player_WeaponSkill;

        public PlayerControls()
        {
            // Load the input actions asset
            m_Asset = Resources.Load<InputActionAsset>("PlayerControls");
            if (m_Asset == null)
            {
                // Create a simple fallback if the asset isn't found
                m_Asset = ScriptableObject.CreateInstance<InputActionAsset>();
                m_Asset.name = "PlayerControls";
                
                var playerMap = new InputActionMap("Player");
                m_Asset.AddActionMap(playerMap);
                
                playerMap.AddAction("Move", InputActionType.Value, binding: "<Keyboard>/wasd");
                playerMap.AddAction("Look", InputActionType.Value, binding: "<Mouse>/delta");
                playerMap.AddAction("Attack", InputActionType.Button, binding: "<Mouse>/leftButton");
                playerMap.AddAction("Jump", InputActionType.Button, binding: "<Keyboard>/space");
                playerMap.AddAction("Pause", InputActionType.Button, binding: "<Keyboard>/escape");
                playerMap.AddAction("Roll", InputActionType.Button, binding: "<Keyboard>/leftShift");
                playerMap.AddAction("CharSkill", InputActionType.Button, binding: "<Keyboard>/q");
                playerMap.AddAction("WeaponSkill", InputActionType.Button, binding: "<Keyboard>/e");
            }
            
            // Get references to actions
            m_Player = m_Asset.FindActionMap("Player", throwIfNotFound: true);
            m_Player_Move = m_Player.FindAction("Move", throwIfNotFound: true);
            m_Player_Look = m_Player.FindAction("Look", throwIfNotFound: true);
            m_Player_Attack = m_Player.FindAction("Attack", throwIfNotFound: true);
            m_Player_Jump = m_Player.FindAction("Jump", throwIfNotFound: true);
            m_Player_Pause = m_Player.FindAction("Pause", throwIfNotFound: true);
            m_Player_Roll = m_Player.FindAction("Roll", throwIfNotFound: true);
            m_Player_CharSkill = m_Player.FindAction("CharSkill", throwIfNotFound: true);
            m_Player_WeaponSkill = m_Player.FindAction("WeaponSkill", throwIfNotFound: true);
        }

        public void Dispose()
        {
            if (m_Asset != null)
                UnityEngine.Object.DestroyImmediate(m_Asset);
        }

        public InputBinding? bindingMask
        {
            get => m_Asset?.bindingMask;
            set { if (m_Asset != null) m_Asset.bindingMask = value; }
        }

        public ReadOnlyArray<InputDevice>? devices
        {
            get => m_Asset?.devices;
            set { if (m_Asset != null) m_Asset.devices = value; }
        }

        public ReadOnlyArray<InputControlScheme> controlSchemes => m_Asset?.controlSchemes ?? new ReadOnlyArray<InputControlScheme>();

        public bool Contains(InputAction action)
        {
            return m_Asset?.Contains(action) ?? false;
        }

        public void Enable()
        {
            m_Asset?.Enable();
        }

        public void Disable()
        {
            m_Asset?.Disable();
        }

        // Player Actions
        public PlayerActions Player => new PlayerActions(this);
        public InGameActions InGame => new InGameActions(this);
        
        // Action properties for direct access
        public InputAction moveAction => m_Player_Move;
        public InputAction attackAction => m_Player_Attack;
        public InputAction interactAction => m_Player_Attack; // Mapping to available action
        public InputAction jumpAction => m_Player_Jump;

        public class PlayerActions
        {
            private readonly PlayerControls m_Wrapper;
            
            public PlayerActions(PlayerControls wrapper) { m_Wrapper = wrapper; }
            
            public InputAction Move => m_Wrapper.m_Player_Move;
            public InputAction Look => m_Wrapper.m_Player_Look;
            public InputAction Attack => m_Wrapper.m_Player_Attack;
            public InputAction Jump => m_Wrapper.m_Player_Jump;
            public InputAction Pause => m_Wrapper.m_Player_Pause;
            public InputAction Roll => m_Wrapper.m_Player_Roll;
            public InputAction CharSkill => m_Wrapper.m_Player_CharSkill;
            public InputAction WeaponSkill => m_Wrapper.m_Player_WeaponSkill;
            
            public InputActionMap Get() { return m_Wrapper.m_Player; }
            public void Enable() { Get().Enable(); }
            public void Disable() { Get().Disable(); }
            public bool enabled => Get().enabled;
            
            public static implicit operator InputActionMap(PlayerActions set) { return set.Get(); }
            
            public void SetCallbacks(IPlayerActions instance)
            {
                if (m_Wrapper.m_PlayerActionsCallbackInterface != null)
                {
                    Move.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnMove;
                    Move.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnMove;
                    Move.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnMove;
                    Look.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnLook;
                    Look.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnLook;
                    Look.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnLook;
                    Attack.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnAttack;
                    Attack.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnAttack;
                    Attack.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnAttack;
                    Jump.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnJump;
                    Jump.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnJump;
                    Jump.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnJump;
                    Pause.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnPause;
                    Pause.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnPause;
                    Pause.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnPause;
                    Roll.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnRoll;
                    Roll.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnRoll;
                    Roll.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnRoll;
                    CharSkill.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnCharSkill;
                    CharSkill.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnCharSkill;
                    CharSkill.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnCharSkill;
                    WeaponSkill.started -= m_Wrapper.m_PlayerActionsCallbackInterface.OnWeaponSkill;
                    WeaponSkill.performed -= m_Wrapper.m_PlayerActionsCallbackInterface.OnWeaponSkill;
                    WeaponSkill.canceled -= m_Wrapper.m_PlayerActionsCallbackInterface.OnWeaponSkill;
                }
                m_Wrapper.m_PlayerActionsCallbackInterface = instance;
                if (instance != null)
                {
                    Move.started += instance.OnMove;
                    Move.performed += instance.OnMove;
                    Move.canceled += instance.OnMove;
                    Look.started += instance.OnLook;
                    Look.performed += instance.OnLook;
                    Look.canceled += instance.OnLook;
                    Attack.started += instance.OnAttack;
                    Attack.performed += instance.OnAttack;
                    Attack.canceled += instance.OnAttack;
                    Jump.started += instance.OnJump;
                    Jump.performed += instance.OnJump;
                    Jump.canceled += instance.OnJump;
                    Pause.started += instance.OnPause;
                    Pause.performed += instance.OnPause;
                    Pause.canceled += instance.OnPause;
                    Roll.started += instance.OnRoll;
                    Roll.performed += instance.OnRoll;
                    Roll.canceled += instance.OnRoll;
                    CharSkill.started += instance.OnCharSkill;
                    CharSkill.performed += instance.OnCharSkill;
                    CharSkill.canceled += instance.OnCharSkill;
                    WeaponSkill.started += instance.OnWeaponSkill;
                    WeaponSkill.performed += instance.OnWeaponSkill;
                    WeaponSkill.canceled += instance.OnWeaponSkill;
                }
            }
        }
        
        public class InGameActions
        {
            private readonly PlayerControls m_Wrapper;
            
            public InGameActions(PlayerControls wrapper) { m_Wrapper = wrapper; }
            
            public InputAction Move => m_Wrapper.m_Player_Move;
            public InputAction Look => m_Wrapper.m_Player_Look;
            public InputAction Attack => m_Wrapper.m_Player_Attack;
            public InputAction Jump => m_Wrapper.m_Player_Jump;
            public InputAction Pause => m_Wrapper.m_Player_Pause;
            public InputAction Roll => m_Wrapper.m_Player_Roll;
            public InputAction CharSkill => m_Wrapper.m_Player_CharSkill;
            public InputAction WeaponSkill => m_Wrapper.m_Player_WeaponSkill;
            
            // Additional directional and action mappings
            public InputAction GoEast => m_Wrapper.m_Player_Move; // Map to move for east
            public InputAction GoWest => m_Wrapper.m_Player_Move; // Map to move for west
            public InputAction GoNorth => m_Wrapper.m_Player_Move; // Map to move for north
            public InputAction GoSouth => m_Wrapper.m_Player_Move; // Map to move for south
            public InputAction AttackOrThrow => m_Wrapper.m_Player_Attack; // Map to attack
            public InputAction ActionOrCraft => m_Wrapper.m_Player_CharSkill; // Map to char skill
            
            public InputActionMap Get() { return m_Wrapper.m_Player; }
            public void Enable() { Get().Enable(); }
            public void Disable() { Get().Disable(); }
            public bool enabled => Get().enabled;
        }
        
        private IPlayerActions m_PlayerActionsCallbackInterface;

        // IEnumerable<InputAction> implementation
        public IEnumerator<InputAction> GetEnumerator()
        {
            yield return m_Player_Move;
            yield return m_Player_Look;
            yield return m_Player_Attack;
            yield return m_Player_Jump;
            yield return m_Player_Pause;
            yield return m_Player_Roll;
            yield return m_Player_CharSkill;
            yield return m_Player_WeaponSkill;
        }

        // IEnumerable implementation
        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public interface IPlayerActions
        {
            void OnMove(InputAction.CallbackContext context);
            void OnLook(InputAction.CallbackContext context);
            void OnAttack(InputAction.CallbackContext context);
            void OnJump(InputAction.CallbackContext context);
            void OnPause(InputAction.CallbackContext context);
            void OnRoll(InputAction.CallbackContext context);
            void OnCharSkill(InputAction.CallbackContext context);
            void OnWeaponSkill(InputAction.CallbackContext context);
        }
    }
}
